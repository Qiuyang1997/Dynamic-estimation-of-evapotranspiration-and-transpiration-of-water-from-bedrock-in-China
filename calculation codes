###----------PART 1 Calculation of the difference of ET-P ------------------###
import os
import numpy as np
import rasterio
from rasterio.warp import reproject, Resampling
from datetime import datetime, timedelta
import gc

def process_period_daily(start_date, end_date, base_path):
    # Read the main raster file (calculate the mask) and set the mask
    with rasterio.open(os.path.join(base_path, 'soil thickness mask.tif')) as src:
        mask = src.read(1).astype(bool)  # Convert mask to boolean
        profile = src.profile.copy()
        crs = src.crs
        transform = src.transform
        width = src.width
        height = src.height

    # Initialize the cumulative precipitation
    cumulative_precip = np.zeros((height, width), dtype=np.float32)

    # Generate daily date sequences
    current_date = start_date
    dates = []
    while current_date <= end_date:
        dates.append(current_date.strftime('%Y%m%d'))
        current_date += timedelta(days=1)  # Update time window

    # Create an output folder
    output_a_folder = os.path.join(base_path, 'A__daily')
    os.makedirs(output_a_folder, exist_ok=True)

    # 逐日处理数据
    for date in dates:
        sc_file = os.path.join(base_path, 'snowcover', f'sc{date}.tif')
        pre_file = os.path.join(base_path, 'P', f'P{date}.tif')
        et_file = os.path.join(base_path, 'ET', f'ET{date}.tif')

        try:
            # Read the SC file (snow cover)
            with rasterio.open(sc_file) as src_sc:
                sc_data = np.zeros((height, width), dtype=np.float32)
                reproject(
                    source=src_sc.read(1),
                    src_transform=src_sc.transform,
                    src_crs=src_sc.crs,
                    destination=sc_data,
                    dst_transform=transform,
                    dst_crs=crs,
                    resampling=Resampling.nearest
                )
                sc_data = (sc_data <= 0.1).astype(np.float32)  # Masks converted to 0 or 1

            # Read the precipitation file (P)
            with rasterio.open(pre_file) as src_pre:
                pre_data = np.zeros((height, width), dtype=np.float32)
                reproject(
                    source=src_pre.read(1),
                    src_transform=src_pre.transform,
                    src_crs=src_pre.crs,
                    destination=pre_data,
                    dst_transform=transform,
                    dst_crs=crs,
                    resampling=Resampling.bilinear
                )
                # Replace invalid values and filter outliers
                pre_data = np.nan_to_num(pre_data, nan=0.0, posinf=0.0, neginf=0.0)
                pre_data = np.clip(pre_data, 0, 1000)

            #  Read the ET file (ET)
            with rasterio.open(et_file) as src_et:
                et_data = np.zeros((height, width), dtype=np.float32)
                reproject(
                    source=src_et.read(1),
                    src_transform=src_et.transform,
                    src_crs=src_et.crs,
                    destination=et_data,
                    dst_transform=transform,
                    dst_crs=crs,
                    resampling=Resampling.bilinear
                )
                # Replace invalid values and filter outliers
                et_data = np.nan_to_num(et_data, nan=0.0, posinf=0.0, neginf=0.0)
                et_data = np.clip(et_data, 0, 1000)

            
            cumulative_precip = pre_data  # 每日数据直接作为累计输入

            # Calculate(ET-P)，and apply the snowcover mask
            diff_data = (et_data - cumulative_precip) * sc_data
            #diff_data[~mask] = -9999  # Processing of invalid values outside the mask
            diff_data = np.clip(diff_data, -9999, 1e5)  # Limit the difference norm

            # save results
            output_file_a = os.path.join(output_a_folder, f'A{date}.tif')
            profile.update(dtype='float32', nodata=-9999)
            with rasterio.open(output_file_a, 'w', **profile) as dst:
                dst.write(diff_data.astype(np.float32), 1)

            print(f"Done: {date}")

        except Exception as e:
            print(f"Error processing {date}: {str(e)}")
            continue

        # Release memory
        del diff_data, pre_data, et_data, sc_data
        gc.collect()

    return "All done!"

if __name__ == "__main__":
    base_path = r'I:'
    start_date = datetime(2009, 8, 1)
    end_date = datetime(2020, 7, 31)

    print(process_period_daily(start_date, end_date, base_path))


###----------PART 2  Iteratively calculattion of the daily soil available water status------------------###

import os
import numpy as np
import rasterio
from rasterio.windows import from_bounds

# Define the input folder and the paths of related files
input_folder = r"path to A_daily"
soil_file = r"soil available water capacity.tif" ## Calculated based on the wilting coefficient and field water holding capacity
soil_initial_file = r"soil available water capacity initial.tif"## Set as 0 and "soil available water capacity.tif" respectively
output_folder =r"soil water daily"

os.makedirs(output_folder, exist_ok=True)

# Read the soil raster to determine the range and soil moisture capacity information, as well as the metadata
with rasterio.open(soil_file) as soil_src:
    soil_bounds = soil_src.bounds
    soil_capacity = soil_src.read(1).astype(np.float64)
    meta = soil_src.meta

# Read the initial state of soil available water
with rasterio.open(soil_initial_file) as soil_initial_src:
    soil_water = soil_initial_src.read(1).astype(np.float64)

# Obtain all the files that meet the conditions and sort them by date (the second to the ninth digits of the file name: YYYYMMDD)
daily_files = sorted([f for f in os.listdir(input_folder) if f.startswith("A") and f.endswith(".tif")])

for file_name in daily_files:
    date_str = file_name[1:9]  # Extract the date string, such as "20100801"
    current_date = int(date_str)
    file_path = os.path.join(input_folder, file_name)
    print(f"processing file at：{date_str}")

    with rasterio.open(file_path) as evap_src:
        # Obtain the corresponding window based on the range of soil data
        window = from_bounds(*soil_bounds, transform=evap_src.transform)
        evap_data = evap_src.read(1, window=window).astype(np.float64)
        evap_data = np.clip(evap_data, -1e3, 1e3)
        evap_data[np.isnan(evap_data)] = 0
        evap_data[np.isinf(evap_data)] = 0

        # Update soil water value
        evap_diff = evap_data  # initial

        # Positive: When evap_diff > 0, soil available water is consumed
        positive_diff = evap_diff > 0
        if np.any(positive_diff):
            # Calculate the insufficient part of the soil
            soil_deficit = evap_diff[positive_diff] - soil_water[positive_diff]
            soil_deficit[soil_deficit < 0] = 0
            
            soil_water[positive_diff] -= evap_diff[positive_diff]
        # Avoid negative values and ensure that they do not exceed the soil available water capacity
        soil_water = np.clip(soil_water, 0, soil_capacity)

        # Negative: When evap_diff < 0, it indicates an increase in soil water
        negative_diff = evap_diff < 0
        if np.any(negative_diff):
            soil_water[negative_diff] += -evap_diff[negative_diff]
            # If the moisture exceeds the capacity, the soil capacity shall be the limit
            excess = soil_water - soil_capacity
            excess_positive = excess > 0
            if np.any(excess_positive):
                soil_water[excess_positive] = soil_capacity[excess_positive]

    # The updated soil moisture status is saved as daily output, named by date
    daily_output = os.path.join(output_folder, f"{date_str}_soil_water.tif")
    with rasterio.open(daily_output, "w", **meta) as dst:
        dst.write(soil_water.astype(np.float32), 1)
    print(f" {date_str} ：{daily_output}")

print("All done!")

###----------PART 3  Iteratively calculattion of the Evapotranspiration from bedrock-stored water (ET_bedrock)------------------###
import os
import numpy as np
import rasterio
from rasterio.windows import from_bounds

# Define the input and output paths
# Define the input folder and the paths of related files
input_folder = r"path to A_daily"
soil_file = r"soil available water capacity.tif" ## Calculated based on the wilting coefficient and field water holding capacity
soil_initial_file = r"soil available water capacity initial.tif"## Set as the Minimum value of initial with 0 and "soil available water capacity.tif" in part 2
output_folder =r"ET_bedrock daily"

os.makedirs(output_folder, exist_ok=True)

# Read the soil raster to determine the range and soil moisture capacity information, as well as the metadata
with rasterio.open(soil_file) as soil_src:
    soil_bounds = soil_src.bounds
    soil_capacity = soil_src.read(1).astype(np.float64)
    meta = soil_src.meta

# Read the initial state of soil available water
with rasterio.open(soil_initial_file) as soil_initial_src:
    soil_water = soil_initial_src.read(1).astype(np.float64)

# Obtain all the daily data files that meet the conditions.  "AYYYYMMDD.tif"
daily_files = sorted([f for f in os.listdir(input_folder) if f.startswith("A") and f.endswith(".tif")])

# Process the data of each day in a loop and update the soil_water status in real time
for file_name in daily_files:
    # Extract the date in the file (for example, "20100801")
    date_str = file_name[1:9]
    file_path = os.path.join(input_folder, file_name)
    print(f"processing：{date_str}")

    with rasterio.open(file_path) as src:
        # Extract the corresponding window of the current file based on the soil grid range
        window = from_bounds(*soil_bounds, transform=src.transform)
        evap_data = src.read(1, window=window).astype(np.float64)
        
        evap_data = np.clip(evap_data, -1e3, 1e3)
        evap_data[np.isnan(evap_data)] = 0
        evap_data[np.isinf(evap_data)] = 0

    # The moisture variation of the current day
    evap_diff = evap_data.copy()

    # initial value
    daily_bedrock_provided = np.zeros_like(soil_capacity, dtype=np.float64)

    # Water consumption: when evap_diff > 0
    pos_mask = evap_diff > 0
    if np.any(pos_mask):
        # To calculate the soil shortage: shortage = evap_diff - current soil moisture, negative value to zero
        soil_deficit = evap_diff[pos_mask] - soil_water[pos_mask]
        soil_deficit[soil_deficit < 0] = 0
        # Preserve the amount of evapotranspiration obtained from the bedrock on that day (i.e., the insufficient part)
        daily_bedrock_provided[pos_mask] = soil_deficit
        # Update soil water
        soil_water[pos_mask] -= evap_diff[pos_mask]

    # Ensure that the soil_water is between 0 and the soil capacity
    soil_water = np.clip(soil_water, 0, soil_capacity)

    # Negative evapotranspiration: When evap_diff < 0, it indicates soil rehydration (e.g. Precipitation or other process of increasing water content)
    neg_mask = evap_diff < 0
    if np.any(neg_mask):
        # Increase soil available water
        soil_water[neg_mask] += -evap_diff[neg_mask]
        # If the increase exceeds the soil capacity, the excess part will be "discarded", that is, it will be updated to the upper limit of soil capacity
        excess = soil_water - soil_capacity
        exceed_mask = excess > 0
        if np.any(exceed_mask):
            soil_water[exceed_mask] = soil_capacity[exceed_mask]

    # SAVE
    daily_output = os.path.join(output_folder, f"{date_str}_bedrock_provided.tif")
    with rasterio.open(daily_output, "w", **meta) as dst:
        dst.write(daily_bedrock_provided.astype(np.float32), 1)

    print(f" {date_str} ：{daily_output}")

print("All done!")

###----------PART 4  Iteratively calculattion of the vegetation transpiration from bedrock-stored water (VT_bedrock)------------------###
import os
import numpy as np
import rasterio
from rasterio.windows import from_bounds

# Define the input and output paths
# Define the input folder and the paths of related files
input_folder = r"I:\A_daily"  
soil_file = r"soil available water capacity.tif" ## Calculated based on the wilting coefficient and field water holding capacity
soil_initial_file = r"soil available water capacity initial.tif"## Set as the Minimum value of initial with 0 and "soil available water capacity.tif" in part 2

vt_data_folder = r"path to daily vegetation transpiration fata"  
daily_output_folder = r"VT_bedock daily"  
os.makedirs(daily_output_folder, exist_ok=True)


# Read soil-related data
with rasterio.open(soil_file) as soil_src:
    soil_bounds = soil_src.bounds
    soil_capacity = soil_src.read(1).astype(np.float64)
    meta = soil_src.meta

with rasterio.open(soil_initial_file) as soil_initial_src:
    soil_initial = soil_initial_src.read(1).astype(np.float64)

# initial soil available water
soil_water = soil_initial.copy()


# Obtain all daily data files and sort them by date

daily_files = [file_name for file_name in os.listdir(input_folder)
               if file_name.startswith("A") and file_name.endswith(".tif")]

daily_files.sort(key=lambda x: x[1:9])


# Iterate through all daily data files for calculation

for file_name in daily_files:
    # Extract the date string (such as "20100801")
    date_str = file_name[1:9]

    # Build the corresponding vt_data file path (named in the format of "VTYYYYMMDD.tif")
    vt_file_name = f"VT{date_str}.tif"
    vt_file_path = os.path.join(ec_data_folder, ec_file_name)

    
    with rasterio.open(ec_file_path) as ec_src:
        window = from_bounds(*soil_bounds, transform=ec_src.transform)
        ec_data = ec_src.read(1, window=window).astype(np.float64)

    # read ET-P
    file_path = os.path.join(input_folder, file_name)
    with rasterio.open(file_path) as evap_src:
        window = from_bounds(*soil_bounds, transform=evap_src.transform)
        evap_data = evap_src.read(1, window=window).astype(np.float64)
        # Limit the range of differ_ data and handle invalid values
        evap_data = np.clip(evap_data, -1e3, 1e3)
        evap_data[np.isnan(evap_data)] = 0
        evap_data[np.isinf(evap_data)] = 0

 # initial
    evap_diff = evap_data
    positive_diff = evap_diff > 0
    negative_diff = evap_diff < 0

    
    daily_rock_water = np.zeros_like(soil_capacity, dtype=np.float64)

    # Water consumption: when evap_diff > 0
    if np.any(positive_diff):
       
        soil_deficit = evap_diff[positive_diff] - soil_water[positive_diff]
        soil_deficit[soil_deficit < 0] = 0
        # Determine whether the current soil available water is lower than the vt_data requirements
        condition = (soil_water[positive_diff] < vt_data[positive_diff])
        # Calculate the amount of vegetation transpiration provided by the bedrock-stored water (VT_bedsrock) and replenish it only when the conditions are not met
        rock_provide = vt_data[positive_diff] - soil_water[positive_diff]
        rock_provide[~condition] = 0

        # updata value
        daily_rock_water[positive_diff] = rock_provide

        
        soil_water[positive_diff] -= evap_diff[positive_diff]

    # Limit soil avaialbe water to no more than its capacity and no less than 0
    soil_water = np.clip(soil_water, 0, soil_capacity)

    # Negative evapotranspiration: When evap_diff < 0, it indicates soil rehydration (e.g. Precipitation or other process of increasing water content)
    if np.any(negative_diff):
        soil_water[negative_diff] += -evap_diff[negative_diff]
        excess = soil_water - soil_capacity
        excess_positive = excess > 0
        if np.any(excess_positive):
            soil_water[excess_positive] = soil_capacity[excess_positive]

    # SAVE
    daily_output_path = os.path.join(daily_output_folder, f"{date_str}_bedrock_water_provide_VT.tif")
    with rasterio.open(daily_output_path, "w", **meta) as dst:
        dst.write(daily_rock_water.astype(np.float32), 1)
    print(f" {date_str} ：{daily_output}")

print("All done!")


