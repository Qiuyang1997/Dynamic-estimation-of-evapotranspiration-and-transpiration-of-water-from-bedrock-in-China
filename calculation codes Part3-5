
###----------PART 3  Iteratively calculattion of the daily soil available water status------------------###

import os
import numpy as np
import rasterio
from rasterio.windows import from_bounds

# Define the input folder and the paths of related files
input_folder = r"path to A_daily"
soil_file = r"soil available water capacity.tif" ## Calculated based on the wilting coefficient and field water holding capacity
soil_initial_file = r"soil available water capacity initial.tif"## Set as 0 and "soil available water capacity.tif" respectively
output_folder =r"soil water daily"

os.makedirs(output_folder, exist_ok=True)

# Read the soil raster to determine the range and soil moisture capacity information, as well as the metadata
with rasterio.open(soil_file) as soil_src:
    soil_bounds = soil_src.bounds
    soil_capacity = soil_src.read(1).astype(np.float64)
    meta = soil_src.meta

# Read the initial state of soil available water
with rasterio.open(soil_initial_file) as soil_initial_src:
    soil_water = soil_initial_src.read(1).astype(np.float64)

# Obtain all the files that meet the conditions and sort them by date (the second to the ninth digits of the file name: YYYYMMDD)
daily_files = sorted([f for f in os.listdir(input_folder) if f.startswith("A") and f.endswith(".tif")])

for file_name in daily_files:
    date_str = file_name[1:9]  # Extract the date string, such as "20100801"
    current_date = int(date_str)
    file_path = os.path.join(input_folder, file_name)
    print(f"processing file at：{date_str}")

    with rasterio.open(file_path) as evap_src:
        # Obtain the corresponding window based on the range of soil data
        window = from_bounds(*soil_bounds, transform=evap_src.transform)
        evap_data = evap_src.read(1, window=window).astype(np.float64)
        evap_data = np.clip(evap_data, -1e3, 1e3)
        evap_data[np.isnan(evap_data)] = 0
        evap_data[np.isinf(evap_data)] = 0

        # Update soil water value
        evap_diff = evap_data  # initial

        # Positive: When evap_diff > 0, soil available water is consumed
        positive_diff = evap_diff > 0
        if np.any(positive_diff):
            # Calculate the insufficient part of the soil
            soil_deficit = evap_diff[positive_diff] - soil_water[positive_diff]
            soil_deficit[soil_deficit < 0] = 0
            
            soil_water[positive_diff] -= evap_diff[positive_diff]
        # Avoid negative values and ensure that they do not exceed the soil available water capacity
        soil_water = np.clip(soil_water, 0, soil_capacity)

        # Negative: When evap_diff < 0, it indicates an increase in soil water
        negative_diff = evap_diff < 0
        if np.any(negative_diff):
            soil_water[negative_diff] += -evap_diff[negative_diff]
            # If the moisture exceeds the capacity, the soil capacity shall be the limit
            excess = soil_water - soil_capacity
            excess_positive = excess > 0
            if np.any(excess_positive):
                soil_water[excess_positive] = soil_capacity[excess_positive]

    # The updated soil moisture status is saved as daily output, named by date
    daily_output = os.path.join(output_folder, f"{date_str}_soil_water.tif")
    with rasterio.open(daily_output, "w", **meta) as dst:
        dst.write(soil_water.astype(np.float32), 1)
    print(f" {date_str} ：{daily_output}")

print("All done!")

###----------PART 4  Iteratively calculattion of the Evapotranspiration from bedrock-stored water (ET_bedrock)------------------###
import os
import numpy as np
import rasterio
from rasterio.windows import from_bounds

# Define the input and output paths
# Define the input folder and the paths of related files
input_folder = r"path to A_daily"
soil_file = r"soil available water capacity.tif" ## Calculated based on the wilting coefficient and field water holding capacity
soil_initial_file = r"soil available water capacity initial.tif"## Set as the Minimum value of initial with 0 and "soil available water capacity.tif" in part 2
output_folder =r"ET_bedrock daily"

os.makedirs(output_folder, exist_ok=True)

# Read the soil raster to determine the range and soil moisture capacity information, as well as the metadata
with rasterio.open(soil_file) as soil_src:
    soil_bounds = soil_src.bounds
    soil_capacity = soil_src.read(1).astype(np.float64)
    meta = soil_src.meta

# Read the initial state of soil available water
with rasterio.open(soil_initial_file) as soil_initial_src:
    soil_water = soil_initial_src.read(1).astype(np.float64)

# Obtain all the daily data files that meet the conditions.  "AYYYYMMDD.tif"
daily_files = sorted([f for f in os.listdir(input_folder) if f.startswith("A") and f.endswith(".tif")])

# Process the data of each day in a loop and update the soil_water status in real time
for file_name in daily_files:
    # Extract the date in the file (for example, "20100801")
    date_str = file_name[1:9]
    file_path = os.path.join(input_folder, file_name)
    print(f"processing：{date_str}")

    with rasterio.open(file_path) as src:
        # Extract the corresponding window of the current file based on the soil grid range
        window = from_bounds(*soil_bounds, transform=src.transform)
        evap_data = src.read(1, window=window).astype(np.float64)
        
        evap_data = np.clip(evap_data, -1e3, 1e3)
        evap_data[np.isnan(evap_data)] = 0
        evap_data[np.isinf(evap_data)] = 0

    # The moisture variation of the current day
    evap_diff = evap_data.copy()

    # initial value
    daily_bedrock_provided = np.zeros_like(soil_capacity, dtype=np.float64)

    # Water consumption: when evap_diff > 0
    pos_mask = evap_diff > 0
    if np.any(pos_mask):
        # To calculate the soil shortage: shortage = evap_diff - current soil moisture, negative value to zero
        soil_deficit = evap_diff[pos_mask] - soil_water[pos_mask]
        soil_deficit[soil_deficit < 0] = 0
        # Preserve the amount of evapotranspiration obtained from the bedrock on that day (i.e., the insufficient part)
        daily_bedrock_provided[pos_mask] = soil_deficit
        # Update soil water
        soil_water[pos_mask] -= evap_diff[pos_mask]

    # Ensure that the soil_water is between 0 and the soil capacity
    soil_water = np.clip(soil_water, 0, soil_capacity)

    # Negative evapotranspiration: When evap_diff < 0, it indicates soil rehydration (e.g. Precipitation or other process of increasing water content)
    neg_mask = evap_diff < 0
    if np.any(neg_mask):
        # Increase soil available water
        soil_water[neg_mask] += -evap_diff[neg_mask]
        # If the increase exceeds the soil capacity, the excess part will be "discarded", that is, it will be updated to the upper limit of soil capacity
        excess = soil_water - soil_capacity
        exceed_mask = excess > 0
        if np.any(exceed_mask):
            soil_water[exceed_mask] = soil_capacity[exceed_mask]

    # SAVE
    daily_output = os.path.join(output_folder, f"{date_str}_bedrock_provided.tif")
    with rasterio.open(daily_output, "w", **meta) as dst:
        dst.write(daily_bedrock_provided.astype(np.float32), 1)

    print(f" {date_str} ：{daily_output}")

print("All done!")

###----------PART 5  Iteratively calculattion of the vegetation transpiration from bedrock-stored water (VT_bedrock)------------------###
import os
import numpy as np
import rasterio
from rasterio.windows import from_bounds

# Define the input and output paths
# Define the input folder and the paths of related files
input_folder = r"I:\A_daily"  
soil_file = r"soil available water capacity.tif" ## Calculated based on the wilting coefficient and field water holding capacity
soil_initial_file = r"soil available water capacity initial.tif"## Set as the Minimum value of initial with 0 and "soil available water capacity.tif" in part 2

vt_data_folder = r"path to daily vegetation transpiration fata"  
daily_output_folder = r"VT_bedock daily"  
os.makedirs(daily_output_folder, exist_ok=True)


# Read soil-related data
with rasterio.open(soil_file) as soil_src:
    soil_bounds = soil_src.bounds
    soil_capacity = soil_src.read(1).astype(np.float64)
    meta = soil_src.meta

with rasterio.open(soil_initial_file) as soil_initial_src:
    soil_initial = soil_initial_src.read(1).astype(np.float64)

# initial soil available water
soil_water = soil_initial.copy()


# Obtain all daily data files and sort them by date

daily_files = [file_name for file_name in os.listdir(input_folder)
               if file_name.startswith("A") and file_name.endswith(".tif")]

daily_files.sort(key=lambda x: x[1:9])


# Iterate through all daily data files for calculation

for file_name in daily_files:
    # Extract the date string (such as "20100801")
    date_str = file_name[1:9]

    # Build the corresponding vt_data file path (named in the format of "VTYYYYMMDD.tif")
    vt_file_name = f"VT{date_str}.tif"
    vt_file_path = os.path.join(ec_data_folder, ec_file_name)

    
    with rasterio.open(ec_file_path) as ec_src:
        window = from_bounds(*soil_bounds, transform=ec_src.transform)
        ec_data = ec_src.read(1, window=window).astype(np.float64)

    # read ET-P
    file_path = os.path.join(input_folder, file_name)
    with rasterio.open(file_path) as evap_src:
        window = from_bounds(*soil_bounds, transform=evap_src.transform)
        evap_data = evap_src.read(1, window=window).astype(np.float64)
        # Limit the range of differ_ data and handle invalid values
        evap_data = np.clip(evap_data, -1e3, 1e3)
        evap_data[np.isnan(evap_data)] = 0
        evap_data[np.isinf(evap_data)] = 0

 # initial
    evap_diff = evap_data
    positive_diff = evap_diff > 0
    negative_diff = evap_diff < 0

    
    daily_rock_water = np.zeros_like(soil_capacity, dtype=np.float64)

    # Water consumption: when evap_diff > 0
    if np.any(positive_diff):
       
        soil_deficit = evap_diff[positive_diff] - soil_water[positive_diff]
        soil_deficit[soil_deficit < 0] = 0
        # Determine whether the current soil available water is lower than the vt_data requirements
        condition = (soil_water[positive_diff] < vt_data[positive_diff])
        # Calculate the amount of vegetation transpiration provided by the bedrock-stored water (VT_bedsrock) and replenish it only when the conditions are not met
        rock_provide = vt_data[positive_diff] - soil_water[positive_diff]
        rock_provide[~condition] = 0

        # updata value
        daily_rock_water[positive_diff] = rock_provide

        
        soil_water[positive_diff] -= evap_diff[positive_diff]

    # Limit soil avaialbe water to no more than its capacity and no less than 0
    soil_water = np.clip(soil_water, 0, soil_capacity)

    # Negative evapotranspiration: When evap_diff < 0, it indicates soil rehydration (e.g. Precipitation or other process of increasing water content)
    if np.any(negative_diff):
        soil_water[negative_diff] += -evap_diff[negative_diff]
        excess = soil_water - soil_capacity
        excess_positive = excess > 0
        if np.any(excess_positive):
            soil_water[excess_positive] = soil_capacity[excess_positive]

    # SAVE
    daily_output_path = os.path.join(daily_output_folder, f"{date_str}_bedrock_water_provide_VT.tif")
    with rasterio.open(daily_output_path, "w", **meta) as dst:
        dst.write(daily_rock_water.astype(np.float32), 1)
    print(f" {date_str} ：{daily_output}")

print("All done!")
